# C++ Map: Accessing an Element
## Or, Layers on Layers on Layers

{# TODO #}
{# Fix header sizes #}
{# Fix code sizes #}
{# Wrap codeblocks to 80chrs #}
{# Add background to codeblocks #}
{# Add syntax highlighting to codeblocks (maybe) #}


This post isn't meant to be a put down of C++ (I'm not nearly good enough to
justify doing that), nor is it meant to be any comprehensive guide to using
maps in C++. Part of what makes languages so fun to learn are the small ways
they get you to rethink how to conceptualise or implement a concept. This post
provides an example in a place I didn't expect to find one. It's also a post
from a beginner,

## The Problem

From [exercism.io's 'nucleotide-count' problem](TODO)
> Given a string of DNA (ie containing only the characters `ACGT`) count the
frequencies of each 'nucleotide' (a character in the string).

Our interface looks like this:
```
class Counter
{
    std::map<char, int> ntc;
public:
    Counter(std::string nt);
    int count(char c) const;
    std::map<char, int> nucleotideCounts() const;
}
```
We populate the map of nucleotide frequencies `ntc` when an object is
initialised, and just implement interfaces for retrieving values from the map.
The `count` function returns the frequency for a given nucleotide, and
`nucleotideCounts` returns all frequencies as a map.

Note the `const` declaration after the methods. Coming from C, this was a bit
non-intuitive, but there are some more uses for `const` in C++. There's a good
overview [here](http://duramecho.com/ComputerInformation/WhyHowCppConst.html).
In our case, it's necessary because we want to tell the C++ compiler that we
aren't going to make changes to member variables: we are just going to access
and then return values. The tests that exercism provides with this problem
won't compile unless this declaration is made, which is just as well, as
otherwise it might have taken my a little longer to stumble on this feature.

Finally, we get around to implementing methods. My initial implementation
looked something like this:
```
{% raw %}
Counter::Counter(string dna_string)
{
    ntc = {{'A', 0}, {'C', 0}, {'G', 0}, {'T', 0}};
    for (char c : dna_string)
    {
        ntc[c]++;
    }
}

map<char, int> Counter::nucleotideCounts() const
{
    return ntc;
}

int Counter::count(char c) const
{
    return ntc[c];
}
{% endraw %}
```
As you can see, we don't check for malformed DNA strings yet, but there's a
bigger problem with the above code: it doesn't compile.
```
nucleotide_count.cpp: In member function ‘int Counter::count(char) const’:
nucleotide_count.cpp:16:17: error: passing ‘const std::map<char, int>’ as ‘this’ argument discards qualifiers [-fpermissive]
   16 |     return ntc[c];
      |                 ^
```
You'll recall that we declared the method as being const, promising not to
change any inputs to the method. All we're doing is accessing an element of the
map, so why would the compiler complain that we're violating this promise?

Our constructor provides the last clue we need to pinpoint the problem. When
given a key not currently in the map, it doesn't throw any errors, despite (in
theory) performing addition with an object that doesn't exist. In fact, it
works as if the value of any new key was already initialed to 0:
```
{% raw %}
void main()
{
    const Counter c = Counter("BAR");
    map<char, int> m = c.nucleotideCounts();
    // m = {{'A': 1}, {'B': 1}, {'C': 0}, {'G': 0}, {'R': 1}, {'T': 0}}
}
{% endraw %}
```
When you reach a point like this, there's not much else to do but RTFM.

## The C++ `map` Class
### map::operator[]

### map::find

### map::at

## Why?
